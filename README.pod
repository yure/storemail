=encoding utf8

=pod
 
=head1 NAME
 
StoreMail
 
=head1 SYNOPSIS
 
Mailing service with threaded conversation backend. 
 
=head1 CONFIGURATION

=head2 Config files
 
Setup mailing provider and DB info in config.yml. Example below:

	domain: prevajalska-agencija.si
	catch_all:
	  host: 'imap.gmail.com'
	  port: 993
	  username: 'info@mail.com'
	  password: 'passss'
	  ssl: 1

	gmail:
	  accounts:
	    Info:
	      host: 'imap.gmail.com'
	      port: 993
	      username: 'info@prevajalska-agencija.si'
	      password: 'passss'
	      ssl: 1
	    Sales:
	      domain: prevajalska-agencija.hr 
	      host: 'imap.gmail.com'
	      port: 993
	      username: 'sales@prevajalska-agencija.si'
	      password: 'passs'
	      ssl: 1

	plugins:
	  DBIC:
	    default:
	      dsn: dbi:mysql:dbname=StoreMail
	      schema_class: StoreMail::Schema
	      user: root
	      pass: toor
	      options:
	        mysql_enable_utf8: 1
	Email:
	  transport:
       SMTP:
         host: 'smtp.mandrillapp.com'
         port: 587
         sasl_username: 'info@mail.com'
         sasl_password: 'passss'
	  
=head2 DB deploy

You can easily deploy DB after you have set up config with 

	bin/deploy.pl
	  
=head2 Running services

You need to run dancer application (bin/app.pl), to handle API requests and bin/catchall.pl script to fetch mail from inbox. 
Mails sent are added to send queue so you have to mail queue service to actually send them. 

=head3 Gmail fetch

	bin/get_gmail.pl --start

Options are:
	
	--start Starts daemon
	--stop Stops daemon
	--redirect Redirects all sent mail to set email. Argument must be before --start!
	--logfile Logfile path/name. Argument must be before --start!
	
Log are in logs dir.

PID file is located in run dir in storemail dir. You can set custom path it in config. 
	
	pid_dir: /var/run
	 
You have to set 'domain' and 'gmail' setting in config. Default sleep between tries is 10sec. You can set 'get_gmail_sleep' in config. 

=head4 Initial import

	bin/get_gmail.pl --init

Log is in initial_import_log.txt

=head3 MailQueue service

	bin/mail_queue_daemon.pl --redirect jon.snow@wall.com --start

Options are:
	
	--start Starts daemon
	--stop Stops daemon
	--redirect Redirects all sent mail to set email. Argument must be before --start!
	--logfile Logfile path/name. Argument must be before --start!

By default it checks for new mail on queue every 3sec (setting in config mail_queue_sleep).

	mail_queue_sleep: 3


=head3 Catchall service

perl bin/catchall.pl [-s 5] 

-s --server 
-u --user
-p --password
--ssl
--port
--sleep (duration bettwen checks)
-d --direction (default i = incoming) [i, o]

It is best to use separate inbox and service for outgoing mail.

=head1 Conversations

All API routes start with your domain. 

=head2 Conversation

New conversation is initiated automatically with first message, user adding or subject setting.

=head3 Conversation data

GET /:domain/conversation/:id
	
Returns:

	{
		subject: string
		messages: [ 
			{	
			body: string,
			conversation_id: string,  
			date: string,  
			id: string,  
			sender: string,  
			attachments: [string, string]
			},
		]
		users: [
			{
			email: string,
			name: stirng
			}
		]
	}

=head3 Conversation users

GET /:domain/conversation/:id/users
	
Returns a list of all users bind to conversation:

	{users: [ 
		{
			body: string,
			conversation_id: string,  
			date: string,  
			id: string,  
			sender: string,  
		}	
	]

=head3 All conversations

GET /:domain/conversation/:id/users
	
Returns a list of all conversations from current domain:

	[ 
		{ 
			"id" : "10@prevajalska-agencija.si" 
			"domain": string, 
			"subject" : null, 
			"date" : "2014-05-28 11:03:30", 	
		}, 
	]

=head3 Conversation config

POST /:domain/conversation/:id

Used for: 
- adding and removing users
- setting conversation subject

=head4 Adding user

	{add_user: 1, name: string, email: string }

=head4 Removing user

	{remove_user: 1, email: string}

=head4 Setting subject
It can only be set once.

	{subject: string}

Returns:

	1 if successful
	0 if unsuccessful

=head3 Adding messages

POST /:domain/conversation/:id/message
Adds message to conversation and sends it around.

	{
		sender_email: string (must be one of conversation users)		
		body: string
		send_copy: 1 (optional, send mail to sender)
	}

Returns:

	{
		error: String (optional)
	}

=head3 Attachments

Attachments are added to conversation prior to sending message. 
Any attachments waiting in temp folder will be sent with next message and moved to another folder bind to message and are accessible in 
	
	/attachments/:message_id/:filename

File should be uploaded with form and file field named 'file'. enctype has to be multipart/form-data.

	POST /conversation/:id/upload

Example form:

	<form 
		method="post" 
		action="/prevajalska-agencija.si/conversation/3/upload" 
		enctype="multipart/form-data">
		
			<input name="file" type="file">
			<button type="submit">Upload</button>
	
	</form>

=head2 Message

=head3 Conversation data

GET /:domain/message/:id
	
Returns:

	{ 
		"id" : string, 
		"conversation_id" : string, 
		"body" : string, 		
		"sender" : string, 
		"date" : string, 			
		"sender_email" : string, 
	}
	
=head1 Provider

Wokring GUI example on /:domain/gui/provider/:comma_separated_emails

JS and HTML code in views/provider.html

=head2 Send mail


POST /:domain/message/send

Send email via some GUI. Example use:

		$("#replay-form").submit(function(e) {
				var message = {
					from: this.from.value,
					to: this.to.value,
					cc: this.cc.value,
					bcc: this.bcc.value,
					subject: this.subject.value,
					body: this.body.value,
					body_type: 'html', //(or 'plain by default)
					tags: 'ad,someOtherTag'
					attachments: [
						{
							content: "data:text/plain;base64,Y2131....",
							name: 'text.txt'
						},
				}
	
				$.ajax({
					type : "POST",
					url : '/' + domain + '/message/send',
					data : {data: JSON.stringify(message)},
					dataType : 'json',
					success: function(data) {
						update_con();
					},
				});
				return false; // avoid to execute the actual submit of the form.
			});	
			
=head3 Attachments

Are base64 encoded in JSON-
			
=head4 Sample - add one attachment:

HTML
	<label>Attachments</label>
	<input id="attachment" name="file" type="file"/>

JS
	var attachments = [];
	function readFile(input) {
		    if ( input.files && input.files[0] ) {
		    	var filename = input.files[0].name;
		        var FR= new FileReader();
		        FR.onload = function(e) {		             
		             attachments.push({name: filename, content: e.target.result});
		        };       
		        FR.readAsDataURL( input.files[0] );
		    }
		}
		
		$("#attachment").change(function(){
		    readFile( this );
		});
			

=head2 Get provider emails

GET /:domain/provider/:comma_separated_emails


=head2 Get provider unread emails

GET /:domain/provider/unread/:comma_separated_emails

=head2 Get all unread emails

GET /:domain/message/unread

returns JSON.

Sample:

	{ "messages" : 
		[ 
			{ 
				"from" : "john.doe@gmail.com" 
				"to" : [ "will.smith@gmail.com ], 
				"cc" : [], 
				"bcc" : [], 
				"subject" : "Welcome", 
				"body" : "Hello! Have a nice day! Regards", 
				"attachments" : [], 
			},
			{ 
				"from" : "will.smith@gmail.com" 
				"to" : [ "john.doe@gmail.com ], 
				"cc" : [], 
				"bcc" : [], 
				"subject" : "RE: Welcome", 
				"body" : "Thanks!", 
				"attachments" : [], 
			},
		]
	}


=head2 Tags

You can set, delete, check and retrieve all tags from message.

Example adding 'read' tag:

GET /:domain/message/:id/tag/check/read

	0

GET /:domain/message/:id/tag/add/read

	0

GET /:domain/message/:id/tag/check/read

	1

GET /:domain/message/:id/tag/check/get_all

	{
	   "tags" : [
	      "read",      
	   ]
	}


=head1 GUI

=head2 Conversation thread

GET '/:domain/gui/conversation/:id

Shows messages and lets you reply. 
Lets you manage users and subject of conversation


=cut	
